#include <bits/stdc++.h>
using namespace std;

/*This function takes all the symbols for rock paper scissors (0,1,2), the number of symbols (3), and the value and recursively create
a vector (list) of 3^(k+1) combinations of 0, 1, and 2*/
vector<string> createAllEntries(char* symbols, int symbolNum,  int kvalue){
	vector<string> strings;
	if(kvalue == 1){
		for(int i = 0; i < symbolNum; i++){
			string s;
			s.push_back(symbols[i]);
			strings.push_back(s);
		}
		return strings;
	}
	strings = createAllEntries(symbols, symbolNum, kvalue-1);
	vector<string> strstore;

	for(unsigned int i = 0; i < strings.size(); i++){
		string s = strings[i];
		for(int j = 0; j < symbolNum; j++){
			strstore.push_back(s + symbols[j]);
		}
	}

	return strstore;
}

/*This table takes all elements in the vector (list) generated by the createAllEntries function, and put it in a map, each with the initial value of 0.1,
This table will allows me to keep count of the history occurences*/
void initializeTable(map<string, double> &mytable, vector<string> strings){
  for(unsigned int i = 0; i < strings.size(); i++){
    mytable.insert(map<string,double>::value_type(strings[i],0.1));
	}
}

/*This function takes in the map of all the keys(combinations) and values(how many times that combination occured) and
the most recent history which is a string and find a match for it in the map if it exist, and increment the value of that combination,
this function essentially counts how many times each history combination has occured*/
void insert(map<string, double> &mytable, string historyComb){
  if(mytable.find(historyComb) != mytable.end()){
    mytable[historyComb]++;
  }
}

/*This function takes the opponent's move this round, the array containing the probability of the opponent playing rock, paper, or scissors,
the count of the opponent playing rock, paper, and scissors, the total number of rounds, the recent history vector(list), and the k value. It will
then it will increment the count of rock, paper, or scissors based on what the opponent's move this round was, then it will
 add to the history, if it exceeds the k value, it will remove the oldest element in the vector (list)
 , then updates the probability of rock, paper, and scissors in the array accordingly */
void update(int opponent, double array[], double& rockCount, double& paperCount, double& scissorCount,int total, vector<int>& vect, int kvalue){

  /*Depending on what the opponent's move was, updates the count, and adds to the history*/
  if(opponent == 0){
    rockCount=rockCount+1;
    if(total<=kvalue+1){
      vect.insert(vect.begin(),0);
    }
    else{
      vect.insert(vect.begin(),0);
      vect.pop_back();
    }
  }
  else if (opponent == 1){
    paperCount=paperCount+1;
    if(total<=kvalue+1){
      vect.insert(vect.begin(),1);
    }
    else{
      vect.insert(vect.begin(),1);
      vect.pop_back();
    }
  }
  else if (opponent == 2){
    scissorCount=scissorCount+1;
    if(total<=kvalue+1){
      vect.insert(vect.begin(),2);
    }
    else{
      vect.insert(vect.begin(),2);
      vect.pop_back();
    }
  }
  array[0] = (rockCount/(rockCount+paperCount+scissorCount)); //Probability of opponent playing rock
  array[1] = (paperCount/(rockCount+paperCount+scissorCount)); //Probability of opponent playing paper
  array[2] = (scissorCount/(rockCount+paperCount+scissorCount)); //Probability of opponent playing scissor
}

/*This function takes in the map of all the combinations, and the recent history string, and then calculates the sum of P(history2|In = 0,1, and 2), which
equals the number of times the history has occured, which is the denominator of P(choice|history).
It checks all the keys in the map that contains the history string, and sums them all up*/
double conditionalProbDen(map<string, double> historymap, string history2){
  double value=0;
  for(int n = 0; n<3; n++){
    for(map<string,double>::iterator iter = historymap.begin(); iter!=historymap.end(); ++iter){
      char firstchar = (iter->first).at(0);
      string suffixkey = (iter->first).substr(1,(iter->first).size()-1);
      if(suffixkey.compare(history2) == 0 && firstchar == ('0'+n)){
        value+=(iter->second);
      }
    }
  }
  return value;
}

/*This function takes in the combinations map, the recent history string, and the most recent move (symbol) with the history (0,1, or 2) and looks it up in the map,
returning the value that matches the concatenation of the symbol+history, because this function divided by the conditionalProbDen function then multiplied
by the probability of symbol(0,1,or 2) occuring will give us P(symbol|history)*/
double conditionalProbNum(map<string, double> historymap, string history2,char symbol){
  double value = 0.1;
  for(map<string,double>::iterator iter = historymap.begin(); iter!=historymap.end(); ++iter){
    char firstchar = (iter->first).at(0);
    string suffixkey = (iter->first).substr(1,(iter->first).size()-1);
    if(suffixkey.compare(history2) == 0 && firstchar == symbol){
      value = (iter->second);
    }
  }
  return value;
}


/*This function takes in all the P(choice|history), where choice is 0,1, and 2, calculates the utility of each choice the player will make, then
choose the max one if there is a max one, or if there is 2 max, it will randomly choose between those 2 max, if they are all the same, then it will
simply randomly choose 0,1, or 2*/
void chooseBest(double rock, double paper, double scissor){
  double epsilon = 0.00000001;
  double rockUtility = scissor-paper;
  double paperUtility = rock-scissor;
  double scissorUtility = paper-rock;
  bool rockPaperEQ = (fabs(rockUtility-paperUtility)<epsilon); //Checks if utility of rock is equal to paper
  bool rockScissorEQ = (fabs(rockUtility-scissorUtility)<epsilon); //Checks if utility of rock is equal to scissor
  bool paperScissorEQ = (fabs(paperUtility-scissorUtility)<epsilon); //Checks if utility of scissor is equal to paper
  double array[3] = {rockUtility, paperUtility, scissorUtility}; //Array of all the utility values
  char tempArray[] = {'0','2'};
  // for (int index = 0; index < 3; index++) {
  //   cout<<array[index]<<endl;
  // }

  /*All of these below simply chooses which utility is the best, if there are 2 max utilities, it will choose randomly between those 2 maxes*/
  if(rockPaperEQ && rockScissorEQ && paperScissorEQ){
    cout << rand()%3 << endl;
  }
  else if(rockPaperEQ){
    if(!paperScissorEQ && scissorUtility>paperUtility){
      cout << '2' << endl;
    }
    else{
      cout <<rand()%2 << endl;
    }
  }
  else if(rockScissorEQ){
    if(!paperScissorEQ && scissorUtility<paperUtility){
      cout << '1' << endl;
    }
    else{
      int index = rand()%2;
      cout << tempArray[index] << endl;
    }
  }
  else if(paperScissorEQ){
    if(!rockScissorEQ && scissorUtility<rockUtility){
      cout << '0' << endl;
    }
    else{
      cout << (rand()%2)+1 << endl;
    }
  }
  else{
    int largestIndex = 0;
    for (int index = 0; index < 3; index++) {
      if (array[largestIndex] < array[index]) {
          largestIndex = index;
      }
    }
    cout<<largestIndex<<endl;
  }
}

/*I keep track of both k and k+1 history, because I use the k+1 history to calculate all the combinations, and k history to calculate the probabilitys,
so this function allows me to choose which to use when the history is still being formed when the history is less than k*/
string getHistory(string str1, string str2, int kvalue){
  if(str1.length() <= (unsigned int)kvalue){
    return str1;
  }
  else{
    return str2;
  }
}

int main(int argc, char *argv[]){
  srand(time(NULL)); //Seed that randomizes the randomizer
  int kvalue = atoi(argv[1]);
  char symbols[] = {'0','1','2'};
  vector<string> stringEntries=createAllEntries(symbols,3,kvalue+1); //Creates a list of all the 3^k+1 combinations
  vector<int> history; //Buffer for the most recent history
  string historyString; //Buffer for k+1 history
  string historyString2; //Buffer for k history
  string historyString3; //Buffer for choosing between k+1 history and k history
  map <string, double> lookUpTable; //Buffer for Map with all the combinations and their values set to 0.1
  initializeTable(lookUpTable,stringEntries); // Initializes map with all the combinations and their values set to 0.1
  double totalRounds = 0; //Counts total the total rounds that has passed
  double rockCount = 0.1;
  double paperCount = 0.1;
  double scissorCount = 0.1;
  double singleProbArray[3];
  int currentMove;
  int prevMove;
  // cout << "k value = "<< argv[1] << endl;

  while(1){

    //current round
    stringstream result; //Buffer to put the history vector into a string
    // cout << "Enter 0 for Rock, 1 for Paper, 2 for Scissor" << endl;
    cin >> currentMove; //Opponent input
    cout<<"Opponent Plays: "<<currentMove<<endl;
    update(prevMove,singleProbArray,rockCount,paperCount,scissorCount,totalRounds,history,kvalue); //Updates the probability array, counts, and history vector

    //These simply transforms the history vector into string
    copy(history.begin(), history.end(), ostream_iterator<int>(result, ""));
    historyString = result.str();
    if(historyString.length()>=(unsigned int)kvalue){
      historyString2 = historyString.substr(0,kvalue);
    }
    historyString3 = getHistory(historyString,historyString2,kvalue);
    insert(lookUpTable,historyString); //Increment the history count in the map
    if(totalRounds < kvalue){
      cout<< rand()%3 << endl; //chooses randomly between 0, 1, or 2;
    }
    else{
      double choosingRock = (conditionalProbNum(lookUpTable,historyString3,'0')/conditionalProbDen(lookUpTable,historyString3))*singleProbArray[0]; //Probability of Opponent choosing rock given history
      double choosingPaper = (conditionalProbNum(lookUpTable,historyString3,'1')/conditionalProbDen(lookUpTable,historyString3))*singleProbArray[1]; //Probability of Opponent choosing paper given history
      double choosingScissor= (conditionalProbNum(lookUpTable,historyString3,'2')/conditionalProbDen(lookUpTable,historyString3))*singleProbArray[2]; //Probability of Opponent choosing scissors given history
      chooseBest(choosingRock,choosingPaper,choosingScissor); //Prints out which move to make
    }
    //updating status from current round
    totalRounds=totalRounds+1;
    prevMove = currentMove; //sets this round's move as the previous move to update the history
  }
  return 0;
}
